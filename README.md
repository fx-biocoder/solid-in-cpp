# SOLID Design Principles in C++

## Introduction
SOLID is a set of five design principles that can be used to create software that is more maintainable, scalable, and adaptable. Each letter in the SOLID acronym stands for a different principle:

1. The Single Responsibility Principle (SRP) suggests that a class or module should have only one reason to change. This means that it should have only one responsibility or function within the system.

2. The Open/Closed Principle (OCP) suggests that a class or module should be open for extension but closed for modification. This means that it should be possible to add new functionality to the system without having to modify existing code.

3. The Liskov Substitution Principle (LSP) suggests that a subclass or subtype should be substitutable for its base class or type. This means that any object or instance of a subtype should be able to be used in place of an instance of its base type without affecting the correctness of the program.

4. The Interface Segregation Principle (ISP) suggests that a class should not be forced to implement interfaces that it does not use. This means that a class should only depend on the interfaces that it actually needs, rather than being forced to depend on large, monolithic interfaces that contain many methods or properties.

5. The Dependency Inversion Principle (DIP) suggests that high-level modules should not depend on low-level modules, but both should depend on abstractions. It also suggests that abstractions should not depend on details, but details should depend on abstractions.

By following these principles, developers can create code that is more modular, testable, and maintainable. SOLID principles help to reduce the coupling between different parts of the codebase, making it easier to change or modify the code without affecting other parts of the system. They also help to make the code more adaptable and scalable, which is important for software projects that need to evolve and grow over time.

## Appendix

1. [Single Responsibility Principle (SRP)](https://github.com/fx-biocoder/solid-in-cpp/tree/main/1%20-%20Single%20Responsibility%20Principle)
2. [Open/Closed Principle (OCP)](https://github.com/fx-biocoder/solid-in-cpp/tree/main/2%20-%20Open-Closed%20Principle)
3. [Liskov Substitution Principle (LSP)](https://github.com/fx-biocoder/solid-in-cpp/tree/main/3%20-%20Liskov%20Substition%20Principle)
4. [Interface Segregation principle (ISP)](https://github.com/fx-biocoder/solid-in-cpp/tree/main/4%20-%20Interface%20Segregation%20Principle)
5. [Dependency Inversion Principle](https://github.com/fx-biocoder/solid-in-cpp/tree/main/5%20-%20Dependency%20Inversion%20Principle)


## Author

- Facundo Martínez © 2023

## "I want to help you improve this guide. How can I do it?"

If you have any feedback regarding the contents of this guide, such as corrections or possible additions, please create a new issue [here](https://github.com/fx-biocoder/solid-in-cpp/issues). This will allow me to keep track of future modifications that need to be implemented. I greatly appreciate the valuable feedback I have received from users. However, please note that I prioritize suggestions that are submitted through the appropriate channels, as there have been instances of comments made in bad faith that were disguised as feedback.

## Licensing

The content of this repository is licensed under CC BY-NC-SA 4.0

If you are interested in using the contents of this repository for commercial purposes, please contact me privately to reach an agreement.

## Contributing

If you have found this guide beneficial, kindly consider [supporting me on Ko-Fi](https://ko-fi.com/biocoder). Your contribution will assist me in creating more high-quality free content for the benefit of all.
